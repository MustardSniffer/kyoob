<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Boo.Lang</name>
    </assembly>
    <members>
        <member name="T:Boo.Lang.BooComparer">
            <summary>
            Compares items lexicographically through IEnumerable whenever
            they don't implement IComparable.
            </summary>
        </member>
        <member name="T:Boo.Lang.Builtins">
            <summary>
            boo language builtin functions.
            </summary>
        </member>
        <member name="T:Boo.Lang.DuckTypedAttribute">
            <summary>
            Marks a method, property or field as being duck typed for type
            inference purposes.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Boo.Lang.Environments.ActiveEnvironment" -->
        <member name="M:Boo.Lang.Environments.ActiveEnvironment.With(Boo.Lang.Environments.IEnvironment,Boo.Lang.Procedure)">
            <summary>
            Executes <paramref name="code"/> in the specified <paramref name="environment"/>.
            </summary>
            <param name="environment">environment that should be made active during the execution of <paramref name="code"/></param>
            <param name="code">code to execute</param>
        </member>
        <member name="P:Boo.Lang.Environments.ActiveEnvironment.Instance">
            <summary>
            The active environment.
            </summary>
        </member>
        <member name="T:Boo.Lang.Environments.EnvironmentBoundValue">
            <summary>
            Environment state monad.
            </summary>
        </member>
        <member name="T:Boo.Lang.Environments.InstantiatingEnvironment">
            <summary>
            An <see cref="T:Boo.Lang.Environments.IEnvironment"/> implementation that simply instantiates requested types.
            </summary>
        </member>
        <member name="T:Boo.Lang.Environments.My`1">
            <summary>
            Idiomatic access to the <see cref="T:Boo.Lang.Environments.ActiveEnvironment">active environment</see>.
            
            <example>
            <code>
            <![CDATA[
            if (My<TypeSystemServices>.Instance.IsPrimitive(someType))
            	return true;
            ]]>
            </code>
            </example>
            </summary>
            <typeparam name="TNeed">Type describing the code's need.</typeparam>
        </member>
        <member name="T:Boo.Lang.Hash">
            <summary>
            Hash.
            </summary>
        </member>
        <member name="T:Boo.Lang.ModuleAttribute">
            <summary>
            Marks a type as a boo module.
            </summary>
        </member>
        <member name="T:Boo.Lang.Procedure">
            <summary>
            Similar in purpose to System.Action but avoiding the System.Core.dll dependency.
            </summary>
        </member>
        <member name="T:Boo.Lang.ResourceManager">
            <summary>
            Resource manager.
            </summary>
        </member>
        <member name="T:Boo.Lang.Runtime.AssertionFailedException">
            <summary>
            Raised when an assertion fails.
            The AssertMacro injects code to raise this exception if the provided
            condition evaluates to false.
            </summary>
        </member>
        <member name="T:Boo.Lang.Runtime.RuntimeException">
            <summary>
            Base exception for the Boo runtime.
            </summary>
        </member>
        <member name="M:Boo.Lang.Runtime.DynamicDispatching.DispatcherCache.Get(Boo.Lang.Runtime.DynamicDispatching.DispatcherKey,Boo.Lang.Runtime.DynamicDispatching.DispatcherCache.DispatcherFactory)">
            <summary>
            Gets a dispatcher from the cache if available otherwise
            invokes factory to produce one and then cache it.
            </summary>
            <param name="key">the dispatcher key</param>
            <param name="factory">function to produce a dispatcher in case one it's not yet available</param>
            <returns></returns>
        </member>
        <member name="M:Boo.Lang.Runtime.DynamicDispatching.DispatcherCache.Clear">
            <summary>
            Removes all Dispatchers from the cache.
            </summary>
        </member>
        <member name="T:Boo.Lang.Runtime.ICoercible">
            <summary>
            Support for user defined dynamic conversions.
            
            An use case is a collection class that needs to provide implicit conversions
            to any array type.
            </summary>
        </member>
        <member name="M:Boo.Lang.Runtime.ICoercible.Coerce(System.Type)">
            <summary>
            Coerces the object to the specified type if possible.
            </summary>
            <param name="to">target type</param>
            <returns>returns the coerced object or this</returns>
        </member>
        <member name="F:Boo.Lang.TypeInferenceRules.TypeReferencedByFirstArgument">
            <summary>
            (typeof(T)) as T
            </summary>
        </member>
        <member name="F:Boo.Lang.TypeInferenceRules.TypeReferencedBySecondArgument">
            <summary>
            (, typeof(T)) as T
            </summary>
        </member>
        <member name="F:Boo.Lang.TypeInferenceRules.ArrayOfTypeReferencedByFirstArgument">
            <summary>
            (typeof(T)) as (T)
            </summary>
        </member>
        <member name="F:Boo.Lang.TypeInferenceRules.TypeOfFirstArgument">
            <summary>
            (T) as T
            </summary>
        </member>
        <member name="T:Boo.Lang.TypeInferenceRuleAttribute">
            <summary>
            Adds a special type inference rule to a method.
            
            See Boo.Lang.Compiler.TypeSystem.Services.InvocationTypeInferenceRules.BuiltinRules.
            </summary>
        </member>
    </members>
</doc>
